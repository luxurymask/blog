<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>为什么类的静态属性引用的对象可以作为GC Root</title>
</head>
<body>
<h2><b>为什么类的静态属性引用的对象可以作为GC Root</b></h2>
<p>判断对象是否处于活动状态的可达性分析法中，需要有一些规则来确定GC Roots，Java中采用的几种对象有栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象以及Native方法中引用的对象。</p>
<p>其他三种都好理解，就是类的静态属性引用的对象为啥可以作为GC Root让我很费解。</p>
<p>确实，静态属性引用的对象只有当类卸载的时候才会被回收，但是静态属性引用谁是随时可能被更改的啊，比如指向了null。</p>
<p>假设这样一种情况，垃圾回收器把一个静态属性引用的对象作为了Root，但是这时候这个静态属性被置为null了，那之前这个属性引用的对象后边儿跟着的一串儿对象都可以被回收了，可以因为它是Root造成这些对象都不被回收，那岂不是不完美了？</p>
<p>这个问题确实让人想不通，大概是因为GC考虑的是系统的瞬时快照吧，毕竟确实static属性引用的对象，只要维持着这个引用就不会被回收，大概率存活的时间是很长的。而且上面所说的情况，即使这次GC没回收，下次GC也会回收了，所以设计者做出了这样的设计吧。</p>
</body>
</html>
